# ---
# jupyter:
#   jupytext:
#     formats: ipynb,py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.6.0
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# %% [markdown]
# # Notebook: run all matlab cases using pandas to read data
# Execution takes ~5'' for all 125 cases for both SCALE & SHIFT mat-functions by [GNU Octave](https://www.gnu.org/software/octave/).
#
# > **TIP:**
# > Navigate with the *headers* of this notebook, by installing the [**`@jupyter/toc`** extension](https://github.com/jupyterlab/jupyterlab-toc)
# > from the bottom ("puzzle") item @ the left side bar of Jupyter-lab.
# > <img src="data:image/png;base64,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" alt="image.png">
#
# ----

# %% [markdown]
# # Intialization & jupyter setup

# %%
## To autoreload codein python files here.
# %load_ext autoreload
# %autoreload 2

## Auto-format cells to ease diffs.
# %load_ext lab_black

# %%
## If you change that, restart kernel and clear all outpouts before running it
# #%matplotlib widget
# %matplotlib inline

# %%
import io
import itertools as itt
import logging
import os
import re
import sys
from collections import abc, namedtuple
from pathlib import Path
from pathlib import PurePosixPath as P
from typing import Any, Callable, Dict, Mapping, List
from typing import Sequence as Seq
from typing import Tuple, Union

import numpy as np
import pandas as pd
import qgrid
from columnize import columnize
from matplotlib import pyplot as plt
from pandas import HDFStore
from pandas import IndexSlice as idx
from pandas.core.generic import NDFrame
from pandas.testing import *

import wltp
from graphtik import compose, operation, optional
from pandalone.mappings import Pstep
from wltp import cycler, datamodel, engine
from wltp import io as wio
from wltp import vehicle, vmax
from wltp.experiment import Experiment
from wltp.utils import pwd_changed, yaml_loads

## Add tests/ into `sys.path` to import `vehdb` module.
#
proj_dir = str(Path(wltp.__file__).parents[1] / "tests")
if proj_dir not in sys.path:
    sys.path.insert(0, proj_dir)

import vehdb

idx = pd.IndexSlice
log = logging.getLogger("ipynb.RunMatCases-pandas")
logging.getLogger("blib2to3").propagate = False  # Disable `lab_black` logs.
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s|%(levelname)5.5s|%(name)s:[%(funcName)s]:\n  +--> %(message)s",
    datefmt="%Y-%m-%d,%H:%M:%S",
)
pd.set_option("display.max_columns", 64, "display.max_rows", 130)

NamedTuple = tuple

# %%
from oct2py import Cell
from oct2py import octave as oc

# See https://nbviewer.jupyter.org/github/blink1073/oct2py/blob/master/example/octavemagic_extension.ipynb?create=1
# %load_ext oct2py.ipython
oc.addpath(str(Path("src").absolute()))

# %%
import missingno as msno

# On my linux this lib produces much debug logs about fonts.
l = logging.getLogger("matplotlib.font_manager")
l.propagate = False

# %%
## CONSTANTS
NSAMPLES = 12
COLUMN_LEVELS = ["item", "gear"]
INDEX_LEVELS = ["case", "t"]

# %% [markdown]
# # Matlab files & `mat_db` specifications

# %% [markdown]
# ## `mat_db` *input* files
# The CSV files stored in `Notebooks/Matlab/src`:
#
# - `case.txt`
# - `vehicle.txt`
# - `engine.txt`
# - `gearbox.txt`
# - `phase.txt`
# - `trace.txt` (the original cycle traces, for all classes)
# - `scale.txt`

# %%
# !ls src/*.txt

# %% [markdown]
# ## SCALE *output* files
# Conceptually, the results are stored in CSV files inside `Notebooks/Matlab/outs`:
#
# - `case_result.txt` (partial)
# - `phase_result.txt`
# - `trace_interpolated.txt` (merged in SHIFT cycle, below, always equals original `v_class`)
# - `trace_scaled.tx` (merged in SHIFT cycle, below)

# %% [markdown]
# ## SHIFT *output* files
# Conceptually, the results are stored in CSV files inside `Notebooks/Matlab/outs`:
#
# - `case_result.txt` (partial)
# - `shift.txt`  (the "cycle")
# - `shift_power.txt`  (merged in "cycle")
# - `shift_condensed.txt`  (merged in "cycle")

# %%
# !ls outs/*.txt

# %% [markdown]
# ## `mat_db` specs
# The CSV files stored in `Notebooks/Matlab/src`:
#
# - `case.txt`
# - `vehicle.txt`
# - `engine.txt`
# - `gearbox.txt`
# - `phase.txt`
# - `trace.txt` (the original cycle traces, for all classes)
# - `scale.txt`

# %%
matfile_specs = {
    "case": {
        "path_fmt": "src/%s.txt",
        "kind": "inp",
        "case": int,
        "class": str,
        **dict.fromkeys(
            "do_dsc do_cap do_cmp calc_dsc supp0 excl1 autom merge".split(), bool
        ),
        "t_start": np.int32,
        "veh": np.int,
        **dict.fromkeys(
            "f_dsc v_cap n_min1 n_min12 n_min2d n_min2 n_min3 n_min3a n_min3d n_min3as"
            " n_min3ds n_lim asm_0 n_asm_s n_asm_e".split(),
            np.float64,
        ),
    },
    "vehicle": {
        "path_fmt": "src/%s.txt",
        "kind": "inp",
        "veh": np.int32,
        "#g": np.int32,
        **dict.fromkeys(
            "f_dsc p_rated n_rated n_idle n_max1 m_test m_ro n_lim f0 f1 f2 SM".split(),
            np.float64,
        ),
    },
    "engine": {
        "path_fmt": "src/%s.txt",
        "kind": "inp",
        "veh": int,
        **dict.fromkeys(
            "n p ASM".split(),
            np.float64,
        ),
    },
    "gearbox": {
        "path_fmt": "src/%s.txt",
        "kind": "inp",
        "veh": int,
        "g": "string",
        "ndv": np.float64,
    },  # "g": Matlab need char-array
    "phase": {
        "path_fmt": "src/%s.txt",
        "kind": "inp",
        "class": str,
        "phase": np.float64,
        "length": np.float64,
    },
    "trace": {
        "path_fmt": "src/%s.txt",
        "kind": "inp",
        "class": str,
        "t": np.float64,
        "v": np.float64,
    },
    "scale": {
        "path_fmt": "src/%s.txt",
        "kind": "inp",
        "class": str,
        "algo": str,
        **dict.fromkeys(
            "t_beg t_max t_end".split(),
            np.float64,
        ),
        **dict.fromkeys(
            "r0 a1 b1".split(),
            np.float64,
        ),
    },
    #
    ## RESULT files
    #
    "trace_scaled": {
        "path_fmt": "outs/%s.txt",
        "kind": "out",
    },
    "trace_interpolated": {
        "path_fmt": "outs/%s.txt",
        "kind": "out",
    },
    "phase_result": {
        "path_fmt": "outs/%s.txt",
        "kind": "out",
    },
    "shift": {
        "path_fmt": "outs/%s.txt",
        "kind": "out",
        "doc": "Will receive: trace_interpolated, trace_scaled, shift_power(pivoted), shift_condensed.",
    },
    # "shift_cycles": {
    #     "kind": "out.calced",
    #     "doc": "Concatenate: shift | trace_interpolated | trace_scaled | shift_power(pivoted) | shift_condensed`.",
    # },
    "case_result": {
        "path_fmt": "outs/%s.txt",
        "kind": "out",
        "doc": "Will receive `case`.",
    },
    "shift_power": {
        "path_fmt": "outs/%s.txt",
        "kind": "out",
        "doc": "Will merge in `shift`.",
    },
    "shift_condensed": {
        "path_fmt": "outs/%s.txt",
        "kind": "out",
        "doc": "Will merge in `shift`.",
    },
    #
    ## EXECUTED outs
    #
    "exe_checksums": {
        "kind": "exe",
    },
    "exe_traces": {
        "kind": "exe",
        "doc": "Will merge in `exe_cycles`.",
    },
    "exe_scalars": {
        "kind": "exe",
    },
    "exe_cycles": {
        "kind": "exe",
    },
}


class MatDb(abc.Mapping):
    """Syntactic sugar to translate ``mat_db.foo`` --> ``globals()["df_foo"]`` """

    @property
    def _items(self):
        globs = globals()
        return [k for k in matfile_specs if _mat_db_global(k) in globs]

    def __contains__(self, k):
        return k in self._items

    def __iter__(self):
        return iter(self._items)

    def __len__(self):
        return len(self._items)

    def __getitem__(self, k):
        if k in self:
            return getattr(self, k)
        raise KeyError(k)

    def _repr(self):
        def make_rec(k):
            rec = [k, self.kind(k)]
            rec.extend(self[k].shape if k in items else ("", ""))
            doc = getattr(type(self), k).__doc__ or ""
            rec.append(doc)
            return rec

        fields = matfile_specs
        items = self._items
        recs = [make_rec(k) for k in fields]
        return (
            pd.DataFrame.from_records(
                recs, columns=["field", "kind", "rows", "cols", "doc"]
            )
            .set_index("field")
            .rename_axis(None)
        )

    def _repr_html_(self):
        return self._repr()._repr_html_()

    def _repr_fits_horizontal_(self):
        return self._repr()._repr_fits_horizontal_()

    def _repr_fits_vertical_(self):
        return self._repr()._repr_fits_vertical_()

    def _repr_data_resource_(self):
        return self._repr()._repr_data_resource_()

    def __repr__(self):
        return str(self._repr())

    def clear(self):
        """Clears from GLOBALS all existing `mat_db` variables! """
        globs = globals()
        for k in self:
            k = _mat_db_global(k)
            if k in globs:
                del globs[k]

    def kind(self, k):
        """Key categories (inp | out | exe) or raises KeyError if unknown key. """
        return matfile_specs[k]["kind"]


def _globals_df_getter(k):
    def getter(self):
        return globals()[k]

    return getter


def _mat_db_global(key):
    return f"df_{key}"


## Assign global-getters as `MatDB` properties.
#
for k in matfile_specs:
    prop = property(_globals_df_getter(_mat_db_global(k)))
    if k in matfile_specs and "doc" in matfile_specs[k]:
        prop.__doc__ = matfile_specs[k]["doc"]
    setattr(MatDb, k, prop)


mat_db = MatDb()

# %%
mat_db.clear()
mat_db


# %% [markdown]
# # Read all input/output CSV tables (`mat_db`)

# %%
def read_mat_csv(fpath: str, **read_csv_kw) -> pd.DataFrame:
    """Matlab data-files have spaces columns and are humanly indented. """
    if fpath in matfile_specs:
        basename = fpath
        fpath = matfile_specs[basename]["path_fmt"] % basename
        if "dtype" not in read_csv_kw and basename in matfile_specs:
            read_csv_kw["dtype"] = matfile_specs[basename]
    df = pd.read_csv(fpath, sep=" *, *", engine="python", **read_csv_kw)
    # NO convert_dtypes(), certain columns full of integers must be floats.
    df = df.set_index(df.columns[0])

    return df


def read_all_inputs() -> Dict[str, pd.DataFrame]:
    return {
        name: read_mat_csv(name)
        for name, spec in matfile_specs.items()
        if "path_fmt" in spec
    }


# Assign tables to  `df_XXX` variables so `MatDb` can pick them.
globals().update((f"df_{name}", df) for name, df in read_all_inputs().items())

# %% [markdown]
# ## Inspect RAW Inputs

# %%
mat_db

# %%
display(
    msno.matrix(df_vehicle.replace(0, np.NAN)),
    msno.matrix(df_case.replace(0, np.NAN)),
)

# %%
display("FLAGS:", df_case.select_dtypes(bool).sum())

# %%
# Display all `mat_db` to faciliate inputs-matching & conversions.
#
for name, df in mat_db.items():
    if mat_db.kind(name) == "inp":
        display(name, df.shape, df.head())

# %% [markdown]
# ## Process Inputs

# %%
## Pivot original cycle-traces with classes as separate columns.
#
if len(mat_db.trace.columns) == 2:
    df_trace = mat_db.trace.reset_index().pivot(index="t", columns="class", values="v")
    df_trace.index = df_trace.index.astype(int)
else:
    log.info("Already pivoted `traces`.")
assert df_trace.shape == (1801, 4), df_trace.shape


def get_v_class(cls: Union[int, str]) -> pd.Series:
    """
    Returns a t-indexed cycle-trace for a class (`"class 1"` or 0-based index (3: class 3b))
    """
    try:
        col_idx = int(cls)
        v = mat_db.trace.iloc[:, col_idx]
    except ValueError:
        v = mat_db.trace.loc[:, cls]
    return v.dropna()


assert get_v_class("class 1").shape == get_v_class(0).shape == (1612,)
assert get_v_class("class 3b").shape == get_v_class(-1).shape == (1801,)

mat_db.trace

# %% [markdown]
# ### DB-UPDATE `phase_results`

# %%
## Pivot original cycle-traces with classes as separate columns.
#
if len(mat_db.phase_result.columns) == 3:
    df_phase_result = mat_db.phase_result.reset_index().pivot(
        index="case", columns="phase", values=["v_sum", "t_cmp"]
    )
else:
    log.info("Already pivoted `phase_results`.")
assert df_phase_result.shape == (125, 8) and get_v_class(0).shape == (
    1612,
), df_phase_result.shape

mat_db.phase_result.head()


# %% [markdown]
# ### DB-UPDATE `shift` (FROM `trace_interpolated`, `trace_scaled`, `shift_power` & `shift_condensed`)

# %%
## Concatenate CYCLE result-files:
#  `trace_scaled.txt` and (pivoted on gears) `outs/shift_power.txt` with main cycle from `outs/shift.txt`.
#
def pivot_shift_power_file(df):
    res = df.rename({"n": "n_at_g"}, axis=1).reset_index()
    res = res.pivot(index=INDEX_LEVELS, columns="g", values=["n_at_g", "p_avail"])
    return res.rename_axis(COLUMN_LEVELS, axis=1)


# display(pivot_shift_power_file(mat_db["shift_power"]))  # TC


def prepare_concat_with_multi_columns(df):
    df = df.set_index("t", append=True)
    df = df.set_axis(
        pd.MultiIndex.from_product([df.columns, [""]], names=COLUMN_LEVELS),
        axis=1,
    )
    return df


def concat_result_cycles(mat_db):
    # Convert main cycle's columns into dummy MultyIndex, needed for concat.
    frames = [
        mat_db.trace_interpolated.rename({"v": "v_class"}, axis=1),
        mat_db.trace_scaled.rename({"v": "v_scaled"}, axis=1),
        mat_db.shift,
        pivot_shift_power_file(mat_db.shift_power),
        mat_db.shift_condensed,
    ]
    frames = [
        prepare_concat_with_multi_columns(df) if df.columns.nlevels == 1 else df
        for df in frames
    ]
    res = pd.concat(frames, axis=1, names=COLUMN_LEVELS)
    return res


if len(df_shift.columns) == 8:
    df_shift = concat_result_cycles(mat_db)
display(df_shift.head())

# %%
mat_db

# %% [markdown]
# # Execute SCALE (`scaleTrace()`)

# %%
#######
## Matlab <--> python utils
##


def panda2col(val) -> np.ndarray:
    """Convert any pandas to numpy, and series into a 1xN column-arrays."""

    if isinstance(val, pd.DataFrame):
        val = [panda2col(col_tuple[1]) for col_tuple in val.iteritems()]
    elif isinstance(val, pd.Series):
        # Matlab needs char-array for `Ndv.gears`.
        dtype = str if isinstance(val.dtype, (str, pd.StringDtype)) else None
        val = val.to_numpy(dtype=dtype).reshape(-1, 1)
    elif isinstance(val, bool):
        val = np.bool_(val)  # or Mat's `validateattributes()` screams.
    return val


def columnize_pandas(*args) -> list:
    """Numpy-ize & columnize any pandas args. """
    return [panda2col(v) for v in args]


def mat_ize(ntuple):
    """Columnize all values of a (named) tuple."""
    mat_ized = columnize_pandas(*ntuple)
    return type(ntuple)(*mat_ized)


def cell_columns_to_df(cell: Cell, **df_kw) -> pd.DataFrame:
    """Turn a cell-array of columns into a DataFrame."""
    return pd.DataFrame(np.hstack(tuple(cell)), **df_kw)


# %%
TraceScaledInps = namedtuple(
    "TraceScaledInps",
    ## Order is important when callling mat-functions!
    """
    ApplyDownscaling ApplySpeedCap ApplyDistanceCompensation UseCalculatedDownscalingPercentage
    DownscalingPercentage ScalingStartTimes ScalingCorrectionTimes ScalingEndTimes
    ScalingAlgorithms CappedSpeed PhaseLengths Trace VehicleClass RatedEnginePower
    VehicleTestMass f0 f1 f2
     """.split(),
)

TraceScaledOuts = namedtuple(
    "TraceScaledOuts",
    "case veh"  # Not outs, added for reference
    ## Order is important when callling mat-functions!
    """
    RequiredToRatedPowerRatio CalculatedDownscalingPercentage RequiredToRatedPowerRatios
    CalculatedDownscalingPercentages TotalChecksum PhaseChecksums MaxVehicleSpeed
    TotalDistance DistanceCompensatedPhaseLengths OriginalTrace ApplicableTrace
    """.split(),
)


def extract_scale_trace_inputs(
    case_no: int, mat_db: Dict[str, pd.DataFrame], **overrides
) -> dict:
    """
    Return an ordered dictionary with (pandas) values for mat-function `scaleTrace.m`.

    :return:
        data are regular pandas
        (apply :func:`columnize_pandas()` before calling matlab)
    """

    case = mat_db["case"].loc[case_no]
    case_class = case["class"]

    veh_no = case.veh
    veh = mat_db["vehicle"].loc[veh_no]
    veh_class = veh["class"]

    scale = mat_db["scale"].loc[veh_class]
    phase = mat_db["phase"].loc[veh_class]
    trace = get_v_class(case_class).reset_index()

    args = TraceScaledInps(
        **{
            # CASE
            "VehicleClass": case_class,
            "ApplyDownscaling": case.do_dsc,
            "ApplySpeedCap": case.do_cap,
            "ApplyDistanceCompensation": case.do_cmp,
            "UseCalculatedDownscalingPercentage": case.calc_dsc,
            # case.txt:f_dsc contains fraction (0-->1), but DownscalingPercentage expects percentage.
            "DownscalingPercentage": 100 * case.f_dsc,
            "CappedSpeed": case.v_cap,
            # VEHICLE
            "RatedEnginePower": veh.p_rated,
            "VehicleTestMass": veh.m_test,
            "f0": veh.f0,
            "f1": veh.f1,
            "f2": veh.f2,
            # SCALE, PHASE & TRACE
            "ScalingStartTimes": scale.t_beg,
            "ScalingCorrectionTimes": scale.t_max,
            "ScalingEndTimes": scale.t_end,
            "ScalingAlgorithms": scale.algo,
            "PhaseLengths": phase.length,
            "Trace": trace,
        }
    )

    args = args._replace(**overrides)

    return args


def scale_trace(
    case_no: int, mat_db: Dict[str, pd.DataFrame], **overrides
) -> TraceScaledOuts:
    """
    Run `scaleTrace.m` for the given `case_no` in `mat_db`.

    :return:
        results as builtins or numpy-arrays
    """

    df_case = mat_db["case"]
    veh_no = df_case.at[case_no, "veh"]

    args = extract_scale_trace_inputs(case_no, mat_db, **overrides)
    mat_ized = mat_ize(args)
    outputs = oc.scaleTrace(*mat_ized, nout=11)
    outputs = TraceScaledOuts(case_no, veh_no, *outputs)

    outputs = outputs._replace(
        ApplicableTrace=cell_columns_to_df(
            outputs.ApplicableTrace[0],
            columns="t v_scaled is_dsc is_cap is_cmp".split(),
        )
        .astype({"t": int, "is_dsc": bool, "is_cap": bool, "is_cmp": bool})
        .set_index("t"),
        OriginalTrace=cell_columns_to_df(
            outputs.OriginalTrace[0], columns=["t", "v_class"]
        )
        .astype({"t": int})
        .set_index("t"),
    )
    return outputs


def scale_all_traces(
    mat_db: Mapping[int, Union[TraceScaledInps, Exception]]
) -> Mapping[int, Union[TraceScaledOuts, Exception]]:
    """Run `scaleTrace.m` for all cases in in `mat_db`."""

    results = []
    for case_no in mat_db["case"].index:
        try:
            results.append(scale_trace(case_no, mat_db))
        except Exception as ex:
            log.error("Case(%s) failed due to: %s", case_no, ex)
            raise

    return results


# %time scale_results = scale_all_traces(mat_db)

# %% [markdown]
# ## Inspect raw SCALE results

# %%
def lene(i):
    try:
        return len(i)
    except:
        pass


def research_mat_results(case_result: NamedTuple):
    """Decide results to coallesce in a single frame, or need further processing into separate frames."""
    fields = pd.DataFrame(
        {
            "is_scalar": [np.isscalar(v) for v in case_result],
            "len": [lene(v) for v in case_result],
            "size": [getattr(v, "size", None) for v in case_result],
            "squeeze": [
                lene(v.squeeze()) if hasattr(v, "squeeze") else None
                for v in case_result
            ],
            "shape": [getattr(v, "shape", None) for v in case_result],
            "squeeze_shape": [
                v.squeeze().shape if hasattr(v, "squeeze") else None
                for v in case_result
            ],
        },
        index=pd.Index(case_result._fields, name="outvar"),
    )
    fields = fields.sort_values(fields.columns.tolist())
    previews = [
        (name, val.shape, val.sample(NSAMPLES).sort_index())
        if isinstance(val, pd.DataFrame)
        else (f"{name} = {val}",)
        for name, val in case_result._asdict().items()
    ]

    return fields, previews


# Pick the case_no=1 results to research.
scale_fields, previews = research_mat_results(scale_results[0])
display(scale_fields)  # , *previews)


# %% [markdown]
# ## Process *SCALE* results

# %% [markdown]
# ### DB-STORE `exe_scalars` (1st time)

# %%
def merge_scalar_results(results, scalar_fields):
    """ Collect all scalar results in a (hierarchical) dataframe. """
    return pd.DataFrame(
        [[getattr(res, k) for k in scalar_fields] for res in results],
        columns=scalar_fields,
    ).set_index("case")


# Pick the case_no=1 results to research.
df_exe_scalars = merge_scalar_results(
    scale_results, scale_fields.query("is_scalar").index
)

display(
    df_exe_scalars.sample(NSAMPLES).sort_index(),
    df_exe_scalars.describe(),
    msno.matrix(df_exe_scalars.replace(0, np.NAN)),
)


# %% [markdown]
# ### DB-STORE `exe_checksums`

# %%
def merge_scale_phases(scale_results, res_name):
    """Special-purpose hierarchical-concat for `scaleTrace()` results. """
    res = pd.concat(
        [pd.Series(getattr(r, res_name).ravel(), name=r.case) for r in scale_results],
        axis=1,
    )
    res.columns.name = "case"
    res.index.name = "phase"
    return res.T


dfs = {
    "v_sum": merge_scale_phases(scale_results, "PhaseChecksums"),
    "t_comp": merge_scale_phases(scale_results, "DistanceCompensatedPhaseLengths"),
}
df_exe_checksums = pd.concat(dfs.values(), axis=1, keys=dfs.keys())
display(df_exe_checksums.head())


# %% [markdown]
# ### DB-STORE `exe_traces`

# %%
def merge_scale_traces(scale_results):
    """Special-purpose pandas-concat for `scaleTrace()` results. """
    v_classes = {i.case: i.OriginalTrace for i in scale_results}
    v_classes = pd.concat(v_classes.values(), keys=v_classes.keys())

    v_targets = {i.case: i.ApplicableTrace for i in scale_results}
    v_targets = pd.concat(v_targets.values(), keys=v_targets.keys())

    return pd.concat((v_classes, v_targets), axis=1, names=COLUMN_LEVELS)


df_exe_traces = merge_scale_traces(scale_results)

df_exe_traces.sample(NSAMPLES).sort_index()

# %% [markdown]
# # Execute SHIFT (`calculateShiftpointsNdvFullPC()`)
# Re-display inputs & produced SCALE outputs to select inputs for SHIFT.

# %%
# Display all `mat_db` to faciliate inputs-matching & conversions.
#
display(mat_db)
# for name, df in mat_db.items():
#     if mat_db.kind(name) == "inp":
#         display(name, df.shape, df.head())

# %%
ShitPointsInps = namedtuple(
    "ShitPointsInps",
    ## Order is important when callling mat-functions!
    """
    RatedEnginePower  RatedEngineSpeed  IdlingEngineSpeed  Max95EngineSpeed  NoOfGears  VehicleTestMass f0  f1  f2
    Ndv  FullPowerCurve  Trace  SafetyMargin  AdditionalSafetyMargin0  StartEngineSpeed  EndEngineSpeed
    MinDriveEngineSpeed1st  MinDriveEngineSpeed1stTo2nd  MinDriveEngineSpeed2ndDecel  MinDriveEngineSpeed2nd
    MinDriveEngineSpeedGreater2nd  EngineSpeedLimitVMax  MaxTorque  ExcludeCrawlerGear  AutomaticClutchOperation
    SuppressGear0DuringDownshifts  MinDriveEngineSpeedGreater2ndAccel  MinDriveEngineSpeedGreater2ndDecel
    MinDriveEngineSpeedGreater2ndAccelStartPhase  MinDriveEngineSpeedGreater2ndDecelStartPhase  TimeEndOfStartPhase
    DoNotMergeClutchIntoGearsOutput  LimitVehicleSpeedByAvailablePower  ReturnAdjustedEngSpeedsAndAvlPowers
    AllowSlippingClutchFor1stAnd2ndGear
    """.split(),
)

ShiftPointsOuts = namedtuple(
    "ShiftPointsOuts",
    "case veh"  # Not outs, added for reference
    ## Order is important when callling mat-functions!
    """
    CalculatedGearsOutput AverageGearOutput AdjustedMax95EngineSpeed TraceTimesOutput RequiredVehicleSpeedsOutput
    RequiredPowersOutput RequiredEngineSpeedsOutput AvailablePowersOutput PowerCurveOutput MaxEngineSpeedCycleOutput
    MaxEngineSpeedReachableOutput MaxEngineSpeedOutput MaxVehicleSpeedCycleOutput MaxVehicleSpeedReachableOutput
    GearMaxVehicleSpeedReachableOutput MinDriveEngineSpeed1stOutput MinDriveEngineSpeed1stTo2ndOutput
    MinDriveEngineSpeed2ndDecelOutput MinDriveEngineSpeed2ndOutput MinDriveEngineSpeedGreater2ndOutput GearsOutput
    ClutchDisengagedOutput ClutchUndefinedOutput ClutchHSTOutput GearCorrectionsOutput ChecksumVxGearOutput
    """.split(),
)


def extract_run_shift_points_inputs(
    case_no: int, mat_db: Dict[str, pd.DataFrame], **overrides
) -> dict:
    """
    Return an ordered dictionary with (pandas) values for mat-function `scaleTrace.m`.

    :return:
        data are regular pandas
        (apply :func:`columnize_pandas()` before calling matlab)
    """

    case = mat_db["case"].loc[case_no]

    veh_no = case.veh
    veh = mat_db["vehicle"].loc[veh_no]

    ## Careful selection of ndv.g.dtype := "string" (Panda's extension-type)
    #  to do the following::
    #      ndv = (ndv.g.to_numpy(str), ndv.ndv)
    ndv = mat_db["gearbox"].loc[veh_no, :].copy()
    ndv["g"] = ndv["g"].str.slice_replace(0, 0, "g")

    wot = mat_db["engine"].loc[veh_no, :].copy()
    # engine.txt:ASM contains fractions [0-->1] but FullPowerCurve.ASM expects percentages.
    wot["ASM"] = wot.ASM * 100

    trace = mat_db.exe_traces.loc[case_no, ["v"]].reset_index(level="t")

    args = ShitPointsInps(
        **{
            # VEHICLE
            "RatedEnginePower": veh.p_rated,  # legacy, derrived from Wot if 0
            "RatedEngineSpeed": veh.n_rated,  # legacy, derrived from Wot if 0
            "IdlingEngineSpeed": veh.n_idle,
            "Max95EngineSpeed": veh.n_max1,
            "NoOfGears": veh["#g"],
            "VehicleTestMass": veh.m_test,
            "f0": veh.f0,
            "f1": veh.f1,
            "f2": veh.f2,
            "SafetyMargin": 100 * veh.SM,  # x100, see note on `wot`, above.
            "Ndv": ndv,
            "FullPowerCurve": wot,
            "Trace": trace,
            # CASE
            "AdditionalSafetyMargin0": case.asm_0,
            "StartEngineSpeed": case.n_asm_s,
            "EndEngineSpeed": case.n_asm_e,
            "MinDriveEngineSpeed1st": case.n_min1,
            "MinDriveEngineSpeed1stTo2nd": case.n_min12,
            "MinDriveEngineSpeed2ndDecel": case.n_min2d,
            "MinDriveEngineSpeed2nd": case.n_min2,
            "MinDriveEngineSpeedGreater2nd": case.n_min3,
            "EngineSpeedLimitVMax": case.n_lim,
            "MaxTorque": 0,  # DEFUNCT
            "ExcludeCrawlerGear": case.excl1,
            "AutomaticClutchOperation": case.autom,
            "SuppressGear0DuringDownshifts": case.supp0,
            "MinDriveEngineSpeedGreater2ndAccel": case.n_min3a,
            "MinDriveEngineSpeedGreater2ndDecel": case.n_min3d,
            "MinDriveEngineSpeedGreater2ndAccelStartPhase": case.n_min3as,
            "MinDriveEngineSpeedGreater2ndDecelStartPhase": case.n_min3ds,
            "TimeEndOfStartPhase": case.t_start,
            "DoNotMergeClutchIntoGearsOutput": True,  # hard-coded in `calc_all_cases.m` (NOT `case.merge` all false)
            "LimitVehicleSpeedByAvailablePower": True,  # hard-coded in `calc_all_cases.m`
            "ReturnAdjustedEngSpeedsAndAvlPowers": True,  # hard-coded in `calc_all_cases.m`
            "AllowSlippingClutchFor1stAnd2ndGear": False,  # hard-coded in `calc_all_cases.m`
        }
    )

    args = args._replace(**overrides)

    return args


def run_shift_points_RAW(
    case_no: int, mat_db: Dict[str, pd.DataFrame], **overrides
) -> TraceScaledOuts:
    """
    Run `calculateShiftpointsNdvFullPC.m` for the given `case_no` in `mat_db`.

    "param mat_db:
        must include results of `scale_trace()`, `exe_scalars` & `exe_traces`

    :return:
        results as builtins or numpy-arrays
    """

    df_case = mat_db["case"]
    veh_no = df_case.at[case_no, "veh"]

    args = extract_run_shift_points_inputs(case_no, mat_db, **overrides)
    mat_ized = mat_ize(args)
    outputs = oc.calculateShiftpointsNdvFullPC(*mat_ized, nout=26)
    outputs = ShiftPointsOuts(case_no, veh_no, *outputs)

    return outputs


def run_all_shift_points(
    mat_db: Mapping[int, Union[TraceScaledInps, Exception]],
    results_varname="shift_results_RAW",
) -> Mapping[int, Union[TraceScaledOuts, Exception]]:
    """Run `scaleTrace.m` for all cases in in `mat_db`."""

    globs = globals()
    results = globs.get(results_varname, [])
    globs[results_varname] = results

    for case_no in mat_db["case"].index:
        if len(results) >= case_no:  # cases start from 1
            log.info("Case(%s) SKIPPED, already in results.", case_no)
            continue
        try:
            log.info("Case(%s) ...", case_no)
            results.append(run_shift_points_RAW(case_no, mat_db))
        except Exception as ex:
            log.error("Case(%s) failed due to: %s", case_no, ex)
            raise

    return results


## NOTE:
#      cases appended in "global" `shift_results_RAW` as calculated
#      to provide for interupting & continuing execution.
#
# shift_results_RAW = [run_shift_points_RAW(1, mat_db)]  # TEST-CASE
# del shift_results_RAW  # UNCOMMENT to recalc all vehicles.
# del shift_results_RAW[-1]
# %time shift_results_RAW = run_all_shift_points(mat_db);

# %% [markdown]
# ## Inspect raw SCALE results

# %%
# Pick the case_no=1 results to research.
shift_fields, previews = research_mat_results(shift_results_RAW[0])
display(
    shift_fields,
)  # *previews)

# %% [markdown]
# ## Process SHIFT results (& combine with SCALE results)
# Roughly make x2 (hierarchical by case) frames in `mat_db`: 
# - `exe_scalars` (updated), 
# - `shift_cycles`

# %%
df_shift_scalars = merge_scalar_results(
    shift_results_RAW, shift_fields.query("is_scalar").index
)

display(
    #     df_shift_scalars.sample(NSAMPLES).sort_index(),
    df_shift_scalars.head(),
    df_shift_scalars.describe(),
    msno.matrix(df_shift_scalars.replace(0, np.NAN)),
    list(mat_db),
)


# %% [markdown]
# ### DB-STORE `exe_cycles` (1st time)

# %%
def convert_booleans(df: pd.DataFrame):
    """Convert to booleans columns with just [0, 1]. """
    nums = df.select_dtypes(np.number)
    booleans = ((nums == 0) | (nums == 1)).all()
    booleans = booleans[booleans].index.tolist()

    return df.astype(dict.fromkeys(booleans, bool))


def merge_shift_cycle(
    case_result: NamedTuple,
    fields: pd.DataFrame,
    field_sizing_column="size",
    time_column="TraceTimesOutput",
):
    """
    Merge all outvars in `case_result` having the same "sizing" as `field_column_match` in `fields`

    and convert any integer/boolean columns."""
    t = getattr(case_result, time_column)
    sizing_value = fields.at[time_column, field_sizing_column]
    query = f"{field_sizing_column} == {sizing_value}"
    columns = [col for col in fields.query(query).index.tolist()]

    res = pd.DataFrame({col: getattr(case_result, col).ravel() for col in columns})

    res = res.convert_dtypes()
    res = convert_booleans(res)

    res.set_index(time_column)
    res.index.name = "t"

    return res


# merge_shift_cycle(shift_results_RAW[0], shift_fields)[5:100] ## TEST_CASE


def concat_cycles(results):
    """Concat case-cycles from SHIFTs only. """
    dfs = {r.case: merge_shift_cycle(r, shift_fields) for r in results}
    cycles = pd.concat(dfs.values(), keys=dfs.keys(), axis=0, names=COLUMN_LEVELS)

    return cycles


shift_cycles = concat_cycles(shift_results_RAW)
shift_cycles

# %%
## Check what other NON-SCALAR fields remain to be converted?
shift_fields.query("not is_scalar and squeeze < 18")


# %% [markdown]
# NOTE: From those above, only `PowerCurveOutput` will not be stored anywhere in `mat_db`,
# which corresponds to `engine_result.txt` file.
#
# The rest will be tansformed into frames, below, and the concatenate with the big CYCLE, further below.

# %%
def conv_CalculatedGearsOutput(cell):
    """This output corresponds to `shift_condensed.txt` file contents."""
    res = pd.DataFrame(
        pd.Series(cell[0][1]).str.strip(),
        index=pd.Index(cell[0][0].ravel(), name="t", dtype=int),
        columns=["gear_or_clutch"],
    )

    return res


# conv_CalculatedGearsOutput(shift_results_RAW[0].CalculatedGearsOutput)  # TEST_CASE


def cell_to_df(cell):
    """This output corresponds to `engine_result.txt` file contents."""
    res = pd.DataFrame(np.hstack(cell.squeeze()))

    return res


# shift_results_RAW[0].PowerCurveOutput  # TEST_CASE


conv_specs = [
    # FIELD, CONVERSION_FUNC, ARGS
    # Corresponds to `shift_condensed.txt`
    ("CalculatedGearsOutput", conv_CalculatedGearsOutput, ()),
    # corresponds to `engine_result.txt`
    ("PowerCurveOutput", cell_to_df, ()),
    ("RequiredEngineSpeedsOutput", cell_to_df, ()),
    ("AvailablePowersOutput", cell_to_df, ()),
]


## Apply specs on results of all cases,
#  and concat in hierarchical sub-frames.
def convert_by_specs(results, conv_specs):
    def apply_spec(field, fun, args):
        dfs = {r.case: fun(getattr(r, field), *args) for r in results}
        out = pd.concat(dfs.values(), keys=dfs.keys(), axis=0, names=COLUMN_LEVELS)

        return out

    return {field: apply_spec(field, *spec) for field, *spec in conv_specs}


shift_dfs = convert_by_specs(shift_results_RAW, conv_specs)
for name, df in shift_dfs.items():
    display(name, df.loc[pd.IndexSlice[:, 10:22], :])

# %% [markdown]
# ## DB-UPDATE `exe_scalars`
# Already containing `SCALE` scalars.

# %%
if len(mat_db.exe_scalars.columns) == 8:
    renames = [
        ("RequiredToRatedPowerRatio", "r_max2"),  # SCALE
        ("CalculatedDownscalingPercentage", "f_dsc2"),  # SCALE
        ("RequiredToRatedPowerRatios", "r_max"),  # SCALE (unused dupe?)
        ("CalculatedDownscalingPercentages", "f_dsc"),  # SCALE (unused dupe?)
        ("TotalChecksum", "v_sum"),  # SCALE
        ("MaxVehicleSpeed", "v_max"),  # SCALE
        ("TotalDistance", "d_cycle"),  # SCALE
        ("AverageGearOutput", "g_avg"),  # SHIFT
        ("ChecksumVxGearOutput", "v_x_g_sum"),  # SHIFT
        ("AdjustedMax95EngineSpeed", "n_max1"),  # SHIFT
        ("MaxEngineSpeedCycleOutput", "n_max2"),  # SHIFT
        ("MaxEngineSpeedReachableOutput", "n_max3"),  # SHIFT
        ("MaxEngineSpeedOutput", "n_max"),  # SHIFT
        ("MaxVehicleSpeedCycleOutput", "v_max_c"),  # SHIFT
        ("MaxVehicleSpeedReachableOutput", "v_max_v"),  # SHIFT
        ("GearMaxVehicleSpeedReachableOutput", "g_v_max"),  # SHIFT
        ("MinDriveEngineSpeed1stOutput", "n_min1"),  # SHIFT
        ("MinDriveEngineSpeed1stTo2ndOutput", "n_min12"),  # SHIFT
        ("MinDriveEngineSpeed2ndDecelOutput", "n_min2d"),  # SHIFT
        ("MinDriveEngineSpeed2ndOutput", "n_min2"),  # SHIFT
        ("MinDriveEngineSpeedGreater2ndOutput", "n_min3"),  # SHIFT
    ]
    rlen = len(renames)
    renames = dict(renames)
    assert len(renames) == rlen, (len(renames), rlen)

    df_exe_scalars = pd.concat((df_exe_scalars, df_shift_scalars), axis=1)
    df_exe_scalars = df_exe_scalars.rename(renames, axis=1)

else:
    log.info("Already merged shift-scalars into `exe_scalars`.")
assert df_exe_scalars.shape == (125, 23), df_exe_scalars.shape

display(mat_db.exe_scalars.sample(NSAMPLES).sort_index(), mat_db.exe_scalars.describe())


# %% [markdown]
# ## DB-STORE `exe_cycles`

# %%

# %%
def concat_exe_cycle(scale_traces, shift_cycles, shift_dfs):
    """
    Make a single (hierarchical by case & time) CYCLES frame with all SHIFT results.

    """
    scale_traces = scale_traces.rename({"v": "v_scaled"}, axis=1)
    scale_traces = scale_traces.set_axis(
        pd.MultiIndex.from_product([scale_traces.columns, [""]]), axis=1
    )

    cycles = shift_cycles.set_axis(
        pd.MultiIndex.from_product([shift_cycles.columns, [""]]), axis=1
    )

    shifts_condensed = shift_dfs["CalculatedGearsOutput"]
    shifts_condensed = shifts_condensed.set_axis(
        pd.MultiIndex.from_product([shifts_condensed.columns, [""]]), axis=1
    )

    shift_dfs = [
        shift_dfs[k].set_axis(
            pd.MultiIndex.from_product(
                # +1 so gears start from 1st
                [[k], shift_dfs[k].columns + 1],
            ),
            axis=1,
        )
        for k in ["RequiredEngineSpeedsOutput", "AvailablePowersOutput"]
    ]

    res = pd.concat(
        (scale_traces, cycles, shifts_condensed, *shift_dfs),
        axis=1,
    )

    renames = [
        ("AvailablePowersOutput", "p_avail"),
        ("ClutchDisengagedOutput", "clutch"),
        ("ClutchHSTOutput", "clutch_HST"),
        ("ClutchUndefinedOutput", "undef"),
        ("GearCorrectionsOutput", "g_corrections"),
        ("GearsOutput", "g"),
        ("RequiredEngineSpeedsOutput", "n_at_g"),
        ("RequiredPowersOutput", "p_req"),
        ("RequiredVehicleSpeedsOutput", "v"),
        ("TraceTimesOutput", "t"),
        # ("gear_or_clutch", ""),
    ]
    rlen = len(renames)
    renames = dict(renames)
    assert len(renames) == rlen, (len(renames), rlen)

    res = (
        res.rename(renames, axis=1)
        .rename_axis(INDEX_LEVELS, axis=0)
        .rename_axis(COLUMN_LEVELS, axis=1)
    )

    ## Check before dropping "time" column (already as index),
    #  which is returned as separate column from SHIFT call.
    #
    assert (res.index.to_frame().t == res.t).all()
    res = res.drop("t", axis=1, level=0)

    return res


df_exe_cycles = concat_exe_cycle(df_exe_traces, shift_cycles, shift_dfs)
df_exe_cycles.iloc[10:20]

# %%
COLUMN_LEVELS

# %%
mat_db


# %% [markdown]
# # Compare "execed"with output-files (`run_all_cases.m`)
# - `case_result` as read from out-file 
# - `exe_scalars` as concatanated  from calling SCALE & SHIFT
#
# and
#
# - `shift` as concated from out-files 
# - `shift_cycles` as concated from calling SCALE & SHIFT

# %% [markdown]
# ## Compare scalars

# %%
def check_frames(a, b):
    ac, bc = set(a.columns), set(b.columns)
    drop = ac - bc
    if drop:
        log.info("To compare, A must drop x%i columns: %s", len(drop), drop)
        a = a.drop(drop, axis=1)
    drop = bc - ac
    if drop:
        log.info("To compare, B must drop x%i columns: %s", len(drop), drop)
        b = b.drop(drop, axis=1)
    a, b = (
        a.rename_axis([None] * a.columns.nlevels, axis=1).sort_index(axis=1),
        b.rename_axis([None] * b.columns.nlevels, axis=1).sort_index(axis=1),
    )
    bad_items = (a != b).all()
    display("DIFFS:", a.columns[bad_items].tolist())
    return a.loc[:, bad_items] - b.loc[:, bad_items]
    # pd.testing.assert_frame_equal(a, b, check_like=True, check_less_precise=True)


diff = check_frames(mat_db.case_result, mat_db.exe_scalars)
display(diff)

# %%
a = diff.abs().max()
display(diff.query(f"r_max == {a.r_max}"), a.r_max)

# %% [markdown]
# ## Compare cycles

# %%
a, b = mat_db.shift, mat_db.exe_cycles

## Check cycle columns match
#
ac, bc = set(df_shift.columns.sort_values()), set(df_exe_cycles.columns.sort_values())
assert not any([ac - bc, bc - ac]), (ac - bc, bc - ac)

diff = check_frames(mat_db.shift, mat_db.exe_cycles)

## THESE ARE DIFFS in P_AVAIL calcs! Why??
diff.dropna()

# %% [markdown]
# ## Compare CHEKSUMS? 

# %%
a, b = mat_db.exe_checksums, mat_db.phase_result
l = len(a.columns)  # Reset columnsMAT counts phases from 1.

a.columns = b.columns = range(l)
assert_frame_equal(a, b)
